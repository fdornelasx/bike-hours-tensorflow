# -*- coding: utf-8 -*-
"""Teste vaga - ML Dev

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PeiPda0hJc9pwj7Hh1hjbvmyHnR08pfj
"""

import pandas as pd
import numpy as np
import os

data = pd.read_csv('data/hour.csv')

data.head(5)

"""### Descrição dos dados
- instant: record index
- dteday : date
- season : season (1:springer, 2:summer, 3:fall, 4:winter)
- yr : year (0: 2011, 1:2012)
- mnth : month ( 1 to 12)
- hr : hour (0 to 23)
- holiday : weather day is holiday or not
- weekday : day of the week
- workingday : if day is neither weekend nor holiday is 1, otherwise is 0.
+ weathersit :
- 1: Clear, Few clouds, Partly cloudy, Partly cloudy
- 2: Mist + Cloudy, Mist + Broken clouds, Mist + Few clouds, Mist
- 3: Light Snow, Light Rain + Thunderstorm + Scattered clouds, Light Rain + Scattered clouds
- 4: Heavy Rain + Ice Pallets + Thunderstorm + Mist, Snow + Fog
- temp : Normalized temperature in Celsius. The values are derived via (t-t_min)/(t_max-t_min), t_min=-8, t_max=+39 (only in hourly scale)
- atemp: Normalized feeling temperature in Celsius. The values are derived via (t-t_min)/(t_max-t_min), t_min=-16, t_max=+50 (only in hourly scale)
- hum: Normalized humidity. The values are divided to 100 (max)
- windspeed: Normalized wind speed. The values are divided to 67 (max)
- casual: count of casual users
- registered: count of registered users
- cnt: count of total rental bikes including both casual and registered

### Eliminando a dependência categórica
"""

from sklearn.preprocessing import OneHotEncoder

#preparando colunas que serão alteradas
col_cat_1 = ['season_' + str(i) for i in range(len(data['season'].unique()))]

col_cat_2 = ['weathersit_' + str(i) for i in range(len(data['weathersit'].unique()))]

col_cat_3 = ['mnth_' + str(i) for i in range(len(data['mnth'].unique()))]

col_cat_4 = ['hr_' + str(i) for i in range(len(data['hr'].unique()))]

col_cat_5 = ['weekday_' + str(i) for i in range(len(data['weekday'].unique()))]


col_cat = col_cat_1 + col_cat_2 + col_cat_3 + col_cat_4 + col_cat_5
print("total de colunas categóricas: ",len(col_cat))

ohe = OneHotEncoder()

dados_cat = data[['season', 'weathersit', 'mnth', 'hr', 'weekday']]
dados_cat_oh = ohe.fit_transform(dados_cat)

dados_cat_oh = pd.DataFrame(dados_cat_oh.todense(),columns=col_cat)

data = pd.concat([data, dados_cat_oh], axis=1)

data.head(5)

"""### Dropando colunas ''desnecessárias''"""

trash = ['instant', 'dteday', 'season', 'weathersit', 'weekday', 'atemp', 'mnth', 'workingday', 'hr']
data = data.drop(trash, axis = 1)

data.head(5)

data = data.dropna()

#explicar que a presença deles impacta no resultado
data = data.drop('registered',axis=1)
data = data.drop('casual',axis=1)

X = data.drop(['cnt'],axis=1)

#atributos que serão predictos

#escalonando atributo que será predicto
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
data[['cnt']] = scaler.fit_transform(data[['cnt']])
Y = data[['cnt']]

from sklearn.model_selection import train_test_split
X_treinamento, X_teste, Y_treinamento, Y_teste = train_test_split(X,Y, test_size=0.3)

previsores_colunas = X.columns.tolist()

"""## Tensorflow"""

import tensorflow as tf

Y_treinamento.head(5)

colunas = [tf.feature_column.numeric_column(key = c) for c in previsores_colunas]

funcao_treinamento = tf.estimator.inputs.pandas_input_fn(x = X_treinamento, y = Y_treinamento['cnt'], batch_size=128, num_epochs= None, shuffle= True)

#10k epochs ficou com resultado interessante
#especificar model_dir=os.getcwd() se quiser salvar o modelo
regressor = tf.estimator.DNNRegressor(hidden_units = [4096,4096], feature_columns=colunas, model_dir = os.getcwd(),optimizer=lambda: tf.train.RMSPropOptimizer( learning_rate=tf.train.exponential_decay( learning_rate=0.001, global_step=tf.train.get_global_step(), decay_steps=2000, decay_rate=0.01)))

regressor.train(input_fn = funcao_treinamento, steps = 20000)

funcao_previsao = tf.estimator.inputs.pandas_input_fn(x = X_teste, shuffle=False)

previsoes = regressor.predict(input_fn = funcao_previsao)

valores_previsao = []
for p in regressor.predict(input_fn = funcao_previsao):
    valores_previsao.append(p['predictions'][0])

valores_previsao = np.asarray(valores_previsao).reshape(-1,1)

valores_previsao = scaler.inverse_transform(valores_previsao)
print("valores predictos: ",valores_previsao)

y_teste2 = Y_teste.values.reshape(-1,1)
y_teste2 = scaler.inverse_transform(y_teste2)
print("valores reais: ",y_teste2)

from sklearn.metrics import mean_absolute_error
from sklearn.metrics import mean_squared_error
from math import sqrt
mae = mean_absolute_error(y_teste2, valores_previsao)
rmse = sqrt(mean_squared_error(y_teste2, valores_previsao))

print("Mean Absolut Error: ",mae,"\n","Root Mean Squared Error: ",rmse)

import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(20,5))

ax.plot(y_teste2, label='Real')
ax.plot(valores_previsao, label='Predicto')



ax.set_xlim(right=len(valores_previsao))

ax.legend()

